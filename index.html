<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nextbot Runner</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
  #menu {
    position: absolute;
    inset: 0;
    background: #111;
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 15px;
  }
  button {
    padding: 10px 20px;
    font-size: 18px;
    cursor: pointer;
  }
  #hud {
    position: absolute;
    top: 20px;
    left: 20px;
    color: white;
    font-size: 20px;
    z-index: 10;
    display: none;
  }
</style>
</head>
<body>

<div id="menu">
  <h1>Nextbot Runner</h1>
  <input type="file" id="imgInput" accept="image/*">
  <button id="playBtn">Play</button>
  <p>WASD to move • Mouse to look • SPACE to jump</p>
</div>

<div id="hud">Health: <span id="health">100</span></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>

<script>
let scene, camera, renderer, controls;
let bot;
let velocityY = 0;
const gravity = -0.03;
const floorY = 1.6;
let isOnGround = true;
let playerHealth = 100;
let collisionObjects = [];

document.getElementById("playBtn").onclick = () => {
  const file = document.getElementById("imgInput").files[0];
  if (!file) return alert("Upload a nextbot image first");

  document.getElementById("menu").style.display = "none";
  document.getElementById("hud").style.display = "block";
  init(URL.createObjectURL(file));
};

function init(imgURL) {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202020);

  camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
  camera.position.set(0, floorY, 5);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new THREE.PointerLockControls(camera, document.body);
  document.body.addEventListener("click", () => controls.lock());
  scene.add(controls.getObject());

  // FIXED: Proper lighting setup
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
  directionalLight.position.set(10, 20, 5);
  directionalLight.castShadow = true;
  scene.add(directionalLight);

  // FIXED: Add more lights so it's not dark
  const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x8B4513, 0.3);
  scene.add(hemisphereLight);

  // FLOOR with collision
  const floor = new THREE.Mesh(
    new THREE.BoxGeometry(100, 1, 100),
    new THREE.MeshStandardMaterial({ color: 0x333333 })
  );
  floor.position.y = 0;
  floor.receiveShadow = true;
  scene.add(floor);
  collisionObjects.push(floor);

  // WALLS with collision
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const wallGeo = new THREE.BoxGeometry(100, 10, 1);

  const walls = [
    [0, 5, -50], [0, 5, 50],
    [-50, 5, 0], [50, 5, 0]
  ];

  walls.forEach(p => {
    const w = new THREE.Mesh(wallGeo, wallMat);
    w.position.set(...p);
    if (p[0] !== 0) w.rotation.y = Math.PI / 2;
    w.castShadow = true;
    w.receiveShadow = true;
    scene.add(w);
    collisionObjects.push(w);
  });

  // ADDED: Some obstacles for collision testing
  const obstacleGeo = new THREE.BoxGeometry(5, 5, 5);
  const obstacleMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
  
  for (let i = 0; i < 5; i++) {
    const obstacle = new THREE.Mesh(obstacleGeo, obstacleMat);
    obstacle.position.set(
      Math.random() * 40 - 20,
      2.5,
      Math.random() * 40 - 20
    );
    obstacle.castShadow = true;
    obstacle.receiveShadow = true;
    scene.add(obstacle);
    collisionObjects.push(obstacle);
  }

  // NEXTBOT
  const tex = new THREE.TextureLoader().load(imgURL);
  const aspect = tex.image.width / tex.image.height;
  const botGeo = new THREE.PlaneGeometry(3 * aspect, 3);
  const botMat = new THREE.MeshBasicMaterial({ 
    map: tex, 
    transparent: true,
    side: THREE.DoubleSide
  });
  bot = new THREE.Mesh(botGeo, botMat);
  bot.position.set(0, 1.5, -20);
  scene.add(bot);

  // Enable shadows
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  animate();
}

const keys = {};
onkeydown = e => {
  keys[e.key.toLowerCase()] = true;
  // ADDED: Jump when space is pressed
  if (e.code === 'Space' && isOnGround) {
    velocityY = 0.15;
    isOnGround = false;
  }
};
onkeyup = e => keys[e.key.toLowerCase()] = false;

// ADDED: Simple collision detection
function checkCollision(position) {
  const playerSize = 0.5; // Player collision radius
  
  for (let obj of collisionObjects) {
    if (obj.geometry.type === 'BoxGeometry') {
      const boxSize = obj.geometry.parameters;
      const objPos = obj.position;
      
      // Simple AABB collision
      if (
        position.x < objPos.x + boxSize.width/2 + playerSize &&
        position.x > objPos.x - boxSize.width/2 - playerSize &&
        position.z < objPos.z + boxSize.depth/2 + playerSize &&
        position.z > objPos.z - boxSize.depth/2 - playerSize &&
        position.y < objPos.y + boxSize.height/2 &&
        position.y > objPos.y - boxSize.height/2
      ) {
        return true;
      }
    }
  }
  return false;
}

// ADDED: Nextbot collision with player
function checkBotCollision() {
  const botBox = new THREE.Box3().setFromObject(bot);
  const playerPos = camera.position;
  const playerBox = new THREE.Box3(
    new THREE.Vector3(playerPos.x - 0.3, playerPos.y - 1.6, playerPos.z - 0.3),
    new THREE.Vector3(playerPos.x + 0.3, playerPos.y + 0.2, playerPos.z + 0.3)
  );
  
  if (botBox.intersectsBox(playerBox)) {
    playerHealth -= 0.5;
    document.getElementById('health').textContent = Math.max(0, Math.floor(playerHealth));
    
    // Knockback effect
    const knockbackDir = new THREE.Vector3()
      .subVectors(camera.position, bot.position)
      .normalize()
      .multiplyScalar(0.5);
    camera.position.add(knockbackDir);
    
    if (playerHealth <= 0) {
      alert("Game Over! You got caught by the Nextbot.");
      location.reload();
    }
  }
}

function animate() {
  requestAnimationFrame(animate);

  if (controls?.isLocked) {
    // Store old position for collision checking
    const oldPosition = camera.position.clone();
    
    // Movement
    const speed = 0.15;
    if (keys["w"]) controls.moveForward(speed);
    if (keys["s"]) controls.moveForward(-speed);
    if (keys["a"]) controls.moveRight(-speed);
    if (keys["d"]) controls.moveRight(speed);

    // ADDED: Better gravity and jumping
    velocityY += gravity;
    camera.position.y += velocityY;
    
    // Ground check with collision
    if (camera.position.y <= floorY) {
      camera.position.y = floorY;
      velocityY = 0;
      isOnGround = true;
    }
    
    // Check collision with obstacles
    if (checkCollision(camera.position)) {
      camera.position.copy(oldPosition);
    }

    // Nextbot chase
    const dir = new THREE.Vector3();
    dir.subVectors(camera.position, bot.position).normalize();
    bot.position.add(dir.multiplyScalar(0.05));
    bot.lookAt(camera.position);
    
    // Check if bot catches player
    checkBotCollision();
  }

  renderer.render(scene, camera);
}

onresize = () => {
  if (camera && renderer) {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  }
};
</script>
</body>
</html>