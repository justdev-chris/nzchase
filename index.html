<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Run from Nextbots</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#111; font-family:sans-serif; color:white; }
  #homepage { position:absolute; top:0; left:0; width:100%; height:100%; background:#222; display:flex; flex-direction:column; justify-content:center; align-items:center; }
  input, button { margin:5px; padding:8px; font-size:16px; }
  #game { display:none; width:100%; height:100%; }
</style>
</head>
<body>

<div id="homepage">
  <h1>Run from Nextbots</h1>
  <label>Upload Map (.glb/.gltf)</label>
  <input type="file" id="mapInput" accept=".glb,.gltf"><br>
  <label>Upload Nextbot Image(s)</label>
  <input type="file" id="nextbotImgInput" accept="image/*" multiple><br>
  <button id="playBtn">Play</button>
</div>

<canvas id="game"></canvas>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';

// ====== SCENE & CAMERA ======
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 5);

const renderer = new THREE.WebGLRenderer({canvas:document.getElementById('game'), antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.enableZoom = false;

// ====== LIGHT ======
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5,10,5);
scene.add(light);
scene.add(new THREE.AmbientLight(0x555555));

// ====== PLAYER ======
const player = { mesh: new THREE.Object3D(), speed:0.1 };
scene.add(player.mesh);

// ====== MAP ======
const mapLoader = new GLTFLoader();
let mapLoaded = false;
let mapFile = null;

document.getElementById('mapInput').addEventListener('change', e=>{
  mapFile = e.target.files[0];
});

// ====== NEXTBOTS ======
const nextbots = [];
const nextbotGeometry = new THREE.PlaneGeometry(1,1);
let nextbotFiles = [];

document.getElementById('nextbotImgInput').addEventListener('change', e=>{
  nextbotFiles = Array.from(e.target.files);
});

// ====== START GAME ======
document.getElementById('playBtn').addEventListener('click', ()=>{
  if(!mapFile || nextbotFiles.length===0){ alert("Upload map and at least 1 nextbot!"); return; }
  
  document.getElementById('homepage').style.display = 'none';
  document.getElementById('game').style.display = 'block';
  
  // load map
  const url = URL.createObjectURL(mapFile);
  mapLoader.load(url, gltf=>{
    scene.add(gltf.scene);
    mapLoaded = true;
  });
  
  // load nextbots
  nextbotFiles.forEach(file=>{
    const url = URL.createObjectURL(file);
    const texture = new THREE.TextureLoader().load(url, tex=>{
      tex.needsUpdate = true;
      const aspect = tex.image.width/tex.image.height;
      nextbotGeometry.scale(aspect, 1, 1);
    });
    const material = new THREE.MeshBasicMaterial({map:texture, transparent:true});
    const mesh = new THREE.Mesh(nextbotGeometry.clone(), material);
    mesh.position.set(Math.random()*10-5,1,Math.random()*10-5);
    scene.add(mesh);
    nextbots.push(mesh);
  });
  
  animate();
});

// ====== PLAYER CONTROLS ======
const keys = {};
document.addEventListener('keydown', e=>keys[e.code]=true);
document.addEventListener('keyup', e=>keys[e.code]=false);

document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
document.body.onclick = ()=>document.body.requestPointerLock();

document.addEventListener('mousemove', e=>{
  if(document.pointerLockElement === document.body){
    player.mesh.rotation.y -= e.movementX * 0.002;
    camera.rotation.x -= e.movementY * 0.002;
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
  }
});

// ====== GAME LOOP ======
function animate(){
  requestAnimationFrame(animate);

  // player movement
  let dir = new THREE.Vector3();
  if(keys['KeyW']) dir.z -= 1;
  if(keys['KeyS']) dir.z += 1;
  if(keys['KeyA']) dir.x -= 1;
  if(keys['KeyD']) dir.x += 1;
  dir.applyEuler(player.mesh.rotation).normalize();
  player.mesh.position.addScaledVector(dir, player.speed);
  camera.position.copy(player.mesh.position).add(new THREE.Vector3(0,1.5,0));

  // nextbots chase
  nextbots.forEach(bot=>{
    const dir = new THREE.Vector3().subVectors(player.mesh.position, bot.position);
    if(dir.length()>0.1) dir.normalize().multiplyScalar(0.05);
    bot.position.add(dir);
  });

  renderer.render(scene, camera);
}

// ====== RESIZE ======
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>