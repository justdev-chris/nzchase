<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Nextbot Runner</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
  #menu {
    position: absolute;
    inset: 0;
    background: #111;
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 15px;
  }
  button {
    padding: 10px 20px;
    font-size: 18px;
    cursor: pointer;
  }
</style>
</head>
<body>

<div id="menu">
  <h1>Nextbot Runner</h1>
  <input type="file" id="imgInput" accept="image/*">
  <button id="playBtn">Play</button>
  <p>WASD to move â€¢ Mouse to look</p>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/PointerLockControls.js"></script>

<script>
let scene, camera, renderer, controls;
let bot;
let velocityY = 0;
const gravity = -0.02;
const floorY = 1.6;

document.getElementById("playBtn").onclick = () => {
  const file = document.getElementById("imgInput").files[0];
  if (!file) return alert("Upload a nextbot image first");

  document.getElementById("menu").style.display = "none";
  init(URL.createObjectURL(file));
};

function init(imgURL) {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202020);

  camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
  camera.position.set(0, floorY, 5);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new THREE.PointerLockControls(camera, document.body);
  document.body.addEventListener("click", () => controls.lock());
  scene.add(controls.getObject());

  // LIGHT
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const light = new THREE.DirectionalLight(0xffffff, 0.6);
  light.position.set(5, 10, 5);
  scene.add(light);

  // FLOOR
  const floor = new THREE.Mesh(
    new THREE.BoxGeometry(100, 1, 100),
    new THREE.MeshStandardMaterial({ color: 0x444444 })
  );
  floor.position.y = 0;
  scene.add(floor);

  // WALLS
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
  const wallGeo = new THREE.BoxGeometry(100, 10, 1);

  const walls = [
    [0, 5, -50], [0, 5, 50],
    [-50, 5, 0], [50, 5, 0]
  ];

  walls.forEach(p => {
    const w = new THREE.Mesh(wallGeo, wallMat);
    w.position.set(...p);
    if (p[0] !== 0) w.rotation.y = Math.PI / 2;
    scene.add(w);
  });

  // NEXTBOT
  const tex = new THREE.TextureLoader().load(imgURL);
  const aspect = tex.image.width / tex.image.height;
  const botGeo = new THREE.PlaneGeometry(3 * aspect, 3);
  const botMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
  bot = new THREE.Mesh(botGeo, botMat);
  bot.position.set(0, 1.5, -20);
  scene.add(bot);

  animate();
}

const keys = {};
onkeydown = e => keys[e.key.toLowerCase()] = true;
onkeyup = e => keys[e.key.toLowerCase()] = false;

function animate() {
  requestAnimationFrame(animate);

  if (controls?.isLocked) {
    const speed = 0.15;
    if (keys["w"]) controls.moveForward(speed);
    if (keys["s"]) controls.moveForward(-speed);
    if (keys["a"]) controls.moveRight(-speed);
    if (keys["d"]) controls.moveRight(speed);

    // gravity
    velocityY += gravity;
    camera.position.y += velocityY;
    if (camera.position.y < floorY) {
      camera.position.y = floorY;
      velocityY = 0;
    }

    // nextbot chase
    const dir = new THREE.Vector3();
    dir.subVectors(camera.position, bot.position).normalize();
    bot.position.add(dir.multiplyScalar(0.05));
    bot.lookAt(camera.position);
  }

  renderer.render(scene, camera);
}

onresize = () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
};
</script>
</body>
</html>