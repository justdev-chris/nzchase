<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Run from Nextbots</title>
<style>
  html, body { margin:0; padding:0; overflow:hidden; background:#111; }
  #nextbotImgInput { position:absolute; top:10px; left:10px; z-index:10; }
  #mapInput { position:absolute; top:40px; left:10px; z-index:10; }
</style>
</head>
<body>

<input type="file" id="nextbotImgInput" accept="image/*">
<input type="file" id="mapInput" accept=".glb,.gltf">

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';

// ====== SCENE & CAMERA ======
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 5);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enablePan = false;
controls.enableZoom = false;

// ====== LIGHT ======
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5,10,5);
scene.add(light);
scene.add(new THREE.AmbientLight(0x555555));

// ====== PLAYER ======
const player = { 
  mesh: new THREE.Object3D(), 
  speed: 0.1 
};
scene.add(player.mesh);

// ====== MAP ======
let mapLoaded = false;
const mapLoader = new GLTFLoader();
document.getElementById('mapInput').addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;
  const url = URL.createObjectURL(file);
  mapLoader.load(url, gltf=>{
    scene.add(gltf.scene);
    mapLoaded = true;
  });
});

// ====== NEXTBOTS ======
const nextbots = [];
const nextbotGeometry = new THREE.PlaneGeometry(1,1);

document.getElementById('nextbotImgInput').addEventListener('change', e=>{
  const file = e.target.files[0];
  if(!file) return;
  const url = URL.createObjectURL(file);
  const texture = new THREE.TextureLoader().load(url, tex=>{
    tex.needsUpdate = true;
    // AUTO SCALE
    const aspect = tex.image.width/tex.image.height;
    nextbotGeometry.scale(aspect, 1, 1);
  });

  const material = new THREE.MeshBasicMaterial({map:texture, transparent:true});
  const mesh = new THREE.Mesh(nextbotGeometry.clone(), material);
  mesh.position.set(Math.random()*10-5,1,Math.random()*10-5);
  scene.add(mesh);
  nextbots.push(mesh);
});

// ====== PLAYER CONTROLS ======
const keys = {};
document.addEventListener('keydown', e=>keys[e.code]=true);
document.addEventListener('keyup', e=>keys[e.code]=false);

document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
document.body.onclick = ()=>document.body.requestPointerLock();

document.addEventListener('mousemove', e=>{
  if(document.pointerLockElement === document.body){
    player.mesh.rotation.y -= e.movementX * 0.002;
    camera.rotation.x -= e.movementY * 0.002;
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
  }
});

// ====== GAME LOOP ======
function animate(){
  requestAnimationFrame(animate);

  // player movement
  let dir = new THREE.Vector3();
  if(keys['KeyW']) dir.z -= 1;
  if(keys['KeyS']) dir.z += 1;
  if(keys['KeyA']) dir.x -= 1;
  if(keys['KeyD']) dir.x += 1;
  dir.applyEuler(player.mesh.rotation).normalize();
  player.mesh.position.addScaledVector(dir, player.speed);
  camera.position.copy(player.mesh.position).add(new THREE.Vector3(0,1.5,0));

  // nextbots chase
  nextbots.forEach(bot=>{
    const dir = new THREE.Vector3().subVectors(player.mesh.position, bot.position);
    if(dir.length()>0.1) dir.normalize().multiplyScalar(0.05);
    bot.position.add(dir);
  });

  renderer.render(scene, camera);
}
animate();

// ====== RESIZE ======
window.addEventListener('resize', ()=>{ 
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
